--- src/components/MapComponent.tsx ---
import React, { useEffect, useState, useRef, useCallback } from "react";
import 'leaflet/dist/leaflet.css';

import {
  MapContainer,
  TileLayer,
  Polyline,
  Marker,
  useMap
} from "react-leaflet";
import "leaflet/dist/leaflet.css";

import L from "leaflet";

import styles from "./MapComponent.module.css";

interface LocationPoint {
  latitude: number;
  longitude: number;
  timestamp: string;
}

// Manual fix for default Leaflet icon paths
delete (L.Icon.Default.prototype as any)._getIconUrl;

L.Icon.Default.mergeOptions({
  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),
  iconUrl: require('leaflet/dist/images/marker-icon.png'),
  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),
});

// Helper function to calculate distance between two lat/lng points in meters
function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number) {
  const toRad = (x: number) => (x * Math.PI) / 180;
  const R = 6371000; // Earth radius in meters
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function MapComponent() {
  const [route, setRoute] = useState<LocationPoint[]>([]);
  const [currentIndex, setCurrentIndex] = useState<number>(0);
  const [playing, setPlaying] = useState<boolean>(false);
  const [elapsedTime, setElapsedTime] = useState<number>(0); // seconds
  const [distanceTravelled, setDistanceTravelled] = useState<number>(0); // meters
  const [speed, setSpeed] = useState<number>(0); // meters per second
  const animationRef = useRef<number | null>(null);
  const startTimeRef = useRef<number | null>(null);
  const lastTimestampRef = useRef<string | null>(null);
  const lastPositionRef = useRef<[number, number] | null>(null);
  const progressRef = useRef<number>(0); // progress between currentIndex and next point (0 to 1)

  // Fetch route data
  useEffect(() => {
    fetch("/dummy-route.json")
      .then((res) => res.json())
      .then((data: LocationPoint[]) => {
        setRoute(data);
      });
  }, []);

  // Reset all states when route changes or playback stops
  useEffect(() => {
    if (!playing) {
      setCurrentIndex(0);
      setElapsedTime(0);
      setDistanceTravelled(0);
      setSpeed(0);
      progressRef.current = 0;
      lastTimestampRef.current = null;
      lastPositionRef.current = null;
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    }
  }, [playing, route]);

  // Animate vehicle movement smoothly
  const animate = useCallback(() => {
    if (!playing || route.length === 0) return;

    const currentPoint = route[currentIndex];
    const nextIndex = currentIndex + 1;

    if (nextIndex >= route.length) {
      setPlaying(false);
      return;
    }

    const nextPoint = route[nextIndex];

    // Calculate time difference in seconds
    const currentTime = Date.now();
    if (!startTimeRef.current) startTimeRef.current = currentTime;
    const elapsed = (currentTime - startTimeRef.current) / 1000;
    setElapsedTime(elapsed);

    // Calculate progress between points based on timestamps
    const currentTimestamp = new Date(currentPoint.timestamp).getTime();
    const nextTimestamp = new Date(nextPoint.timestamp).getTime();
    const totalSegmentTime = (nextTimestamp - currentTimestamp) / 1000;

    if (totalSegmentTime <= 0) {
      // If timestamps invalid, fallback to fixed speed
      progressRef.current += 0.01;
    } else {
      const segmentElapsed = elapsed - (currentIndex * totalSegmentTime);
      progressRef.current = Math.min(segmentElapsed / totalSegmentTime, 1);
    }

    // Interpolate position
    const lat = currentPoint.latitude + (nextPoint.latitude - currentPoint.latitude) * progressRef.current;
    const lng = currentPoint.longitude + (nextPoint.longitude - currentPoint.longitude) * progressRef.current;

    // Calculate distance travelled
    if (lastPositionRef.current) {
      const dist = haversineDistance(lastPositionRef.current[0], lastPositionRef.current[1], lat, lng);
      setDistanceTravelled((prev) => prev + dist);
      // Calculate speed (m/s)
      const timeDiff = (currentTime - (lastTimestampRef.current ? new Date(lastTimestampRef.current).getTime() : currentTime)) / 1000;
      if (timeDiff > 0) {
        setSpeed(dist / timeDiff);
      }
    }

    lastPositionRef.current = [lat, lng];
    lastTimestampRef.current = new Date(currentPoint.timestamp).toISOString();

    // Update currentIndex if progress complete
    if (progressRef.current >= 1) {
      setCurrentIndex((prev) => Math.min(prev + 1, route.length - 1));
      progressRef.current = 0;
      startTimeRef.current = Date.now();
    }

    animationRef.current = requestAnimationFrame(animate);
  }, [playing, currentIndex, route]);

  // Start or stop animation
  useEffect(() => {
    if (playing) {
      startTimeRef.current = null;
      animationRef.current = requestAnimationFrame(animate);
    } else {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, [playing, animate]);

  if (route.length === 0) return <p>Loading route...</p>;

  // Calculate current position for marker
  const currentPoint = route[currentIndex];
  const nextPoint = route[Math.min(currentIndex + 1, route.length - 1)];
  const lat = currentPoint.latitude + (nextPoint.latitude - currentPoint.latitude) * progressRef.current;
  const lng = currentPoint.longitude + (nextPoint.longitude - currentPoint.longitude) * progressRef.current;
  const currentPos: [number, number] = [lat, lng];

  // Path so far for polyline
  const pathSoFar: [number, number][] = route
    .slice(0, currentIndex + 1)
    .map((p) => [p.latitude, p.longitude]);

  return (
    <>
      <div className={styles.container}>
        <h2 className={styles.header}>ðŸš— Vehicle Route Simulator (TSX)</h2>
        <div className={styles.mapWrapper}>
          <MapContainer center={currentPos} zoom={15} scrollWheelZoom={true} style={{ height: "100%", width: "100%" }}>
            <TileLayer
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
              attribution="&copy; OpenStreetMap contributors"
            />
            <Marker position={currentPos}></Marker>
            <Polyline positions={pathSoFar} color="blue" />
            <RecenterMap coords={currentPos} />
          </MapContainer>
        </div>

        <div className={styles.controls}>
          <button onClick={() => setPlaying(!playing)} className={styles.button}>
            {playing ? "Pause" : "Play"}
          </button>
          <button onClick={() => {
            setPlaying(false);
            setCurrentIndex(0);
            setElapsedTime(0);
            setDistanceTravelled(0);
            setSpeed(0);
            progressRef.current = 0;
            lastTimestampRef.current = null;
            lastPositionRef.current = null;
          }} className={styles.button}>
            Reset
          </button>
        </div>

        <div className={styles.info}>
          <p><strong>Current Coordinates:</strong> {currentPos[0].toFixed(6)}, {currentPos[1].toFixed(6)}</p>
          <p><strong>Timestamp:</strong> {route[currentIndex].timestamp}</p>
          <p><strong>Elapsed Time:</strong> {Math.floor(elapsedTime)} seconds</p>
          <p><strong>Distance Travelled:</strong> {distanceTravelled.toFixed(2)} meters</p>
          <p><strong>Speed:</strong> {speed.toFixed(2)} m/s</p>
        </div>
      </div>
    </>
  );
}

function RecenterMap({ coords }: { coords: [number, number] }) {
  const map = useMap();
  useEffect(() => {
    map.setView(coords);
  }, [coords]);
  return null;
}

export default MapComponent;

--- src/components/MapComponent.module.css ---
.container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-width: 900px;
  margin: 0 auto;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: #2c3e50;
  background: linear-gradient(135deg, #74ebd5 0%, #ACB6E5 100%);
  padding: 20px;
  box-sizing: border-box;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.15);
}

.header {
  text-align: center;
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 20px;
  color: #1b2735;
  text-shadow: 1px 1px 3px rgba(255,255,255,0.7);
}

.mapWrapper {
  flex-grow: 1;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 6px 18px rgba(0,0,0,0.2);
  margin-bottom: 20px;
  border: 2px solid #4a90e2;
}

.controls {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;
}

.button {
  background-color: #4a90e2;
  border: none;
  color: white;
  padding: 14px 30px;
  font-size: 1.1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
  user-select: none;
  box-shadow: 0 4px 12px rgba(74,144,226,0.6);
}

.button:hover {
  background-color: #357ABD;
  box-shadow: 0 6px 16px rgba(53,122,189,0.8);
}

.info {
  text-align: center;
  font-size: 1.1rem;
  line-height: 1.6;
  color: #1b2735;
  font-weight: 600;
  text-shadow: 0 1px 2px rgba(255,255,255,0.8);
}

.info strong {
  color: #2c3e50;
}

@media (max-width: 600px) {
  .container {
    padding: 15px;
  }
  .button {
    padding: 12px 20px;
    font-size: 1rem;
  }
}

--- src/components/MapComponent.module.css.d.ts ---
declare const styles: {
  readonly container: string;
  readonly header: string;
  readonly mapWrapper: string;
  readonly controls: string;
  readonly button: string;
  readonly info: string;
};
export default styles;

--- src/App.tsx ---
import React from "react";
import MapComponent from "./components/MapComponent";

function App() {
  return (
    <div className="App">
      <MapComponent />
    </div>
  );
}

export default App;

--- package.json ---
{
  "name": "vehicle-movement",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "leaflet": "^1.9.4",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-leaflet": "^5.0.0",
    "react-scripts": "^5.0.1",
    "typescript": "^4.9.5"
  },
  "devDependencies": {
    "@types/leaflet": "^1.9.20",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"]
}

--- public/dummy-route.json ---
[
  {
    "latitude": 37.7749,
    "longitude": -122.4194,
    "timestamp": "2023-07-19T10:00:00Z"
  },
  {
    "latitude": 37.7750,
    "longitude": -122.4180,
    "timestamp": "2023-07-19T10:00:10Z"
  },
  {
    "latitude": 37.7755,
    "longitude": -122.4170,
    "timestamp": "2023-07-19T10:00:20Z"
  },
  {
    "latitude": 37.7760,
    "longitude": -122.4160,
    "timestamp": "2023-07-19T10:00:30Z"
  },
  {
    "latitude": 37.7765,
    "longitude": -122.4150,
    "timestamp": "2023-07-19T10:00:40Z"
  }
]
